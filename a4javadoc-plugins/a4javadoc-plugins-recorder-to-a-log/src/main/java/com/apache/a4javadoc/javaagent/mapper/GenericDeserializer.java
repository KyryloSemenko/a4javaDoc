package com.apache.a4javadoc.javaagent.mapper;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import com.apache.a4javadoc.exception.AppRuntimeException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;

/**
 * This deserializer can process JSON string created by {@link GenericSerializer}.<br>
 * It can process circular references in JSON, where some object contains itself somewhere in its object graph.<br>
 * @author Kyrylo Semenko
 */
@SuppressWarnings("serial")
public class GenericDeserializer extends StdDeserializer<Object> {
    
    /**
     * Values of this map contains already deserialized objects. The keys of the map contains generic identifiers,
     * see the {@link IdentifierService#generateIdentifier(Object)} method.
     */
    private transient Map<String, Object> deserializedObjects;
    
    /** The default constructor */
    public GenericDeserializer() {
        this(null); 
        deserializedObjects = new HashMap<>();
    } 
 
    /**
     * Type of values this deserializer handles. In our case it is {@link Object}.
     * @param valueClass
     */
    public GenericDeserializer(Class<?> valueClass) { 
        super(valueClass); 
        deserializedObjects = new HashMap<>();
    }
 
    @Override
    public Object deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException {
        JsonNode rootNode = jsonParser.getCodec().readTree(jsonParser);
        
        if (rootNode.isNull()) {
            return null;
        }
        
        if (rootNode.get(GenericSerializer.GENERIC_KEY_ID) == null) {
            throw new AppRuntimeException("Cannot parse the JSON because it has no field with key '"
                    + GenericSerializer.GENERIC_KEY_ID
                    + "'. Probably this JSON does not generated by '" + GenericSerializer.class.getName()
                    + "'. Please use the '" + GenericSerializer.class.getName()
                    + "' for serialization an object to JSON. JSON: "
                    + rootNode);
        }
        
        Identifier identifier = IdentifierService.getInstance().createIdentifierFromJsonNode(rootNode.get(GenericSerializer.GENERIC_KEY_ID));
        if (deserializedObjects.containsKey(identifier)) {
            return deserializedObjects.get(identifier);
        }
        return deserializeObject(rootNode.get(GenericSerializer.GENERIC_VALUE), identifier, null);
    }

    /**
     * Recursive method. Create a new instance from the currentNode.
     * @param jsonNode the data source, cannot be 'null'.
     * @param identifier if exists, this {@link Identifier} has been created by {@link GenericSerializer}. Can be 'null'.
     * @param parentInstance deserialized enclosing object of the returned object. Can be 'null'.
     * @return instantiated object of the {@link Identifier#getContainerType()}.{@link ContainerType#getObjectClass()} type.
     */
    private Object deserializeObject(JsonNode jsonNode, Identifier identifier, Object parentInstance) {
        if (jsonNode.isNull()) {
            return null;
        }
        if (identifier == null) {
            identifier = IdentifierService.getInstance().generateIdentifier(jsonNode, parentInstance);
        }
        if (Iterable.class.isAssignableFrom(identifier.getContainerType().getObjectClass())) {
            
        }
        return null;
//        try {
//            Object instance = null;
//            Class<?> clazz = null;
//            String identifier = defaultIdentifier;
//            if (currentNode.has(GenericSerializer.GENERIC_KEY_ID)) {
//                identifier = currentNode.get(GenericSerializer.GENERIC_KEY_ID).asText();
//                if (deserializedObjects.containsKey(identifier)) {
//                    return deserializedObjects.get(identifier);
//                }
//                String className = IdentifierService.getInstance().findClassName(identifier);
//                clazz = Class.forName(className);
//                currentNode = currentNode.get(GenericSerializer.GENERIC_VALUE);
//            } else {
////                if (containerTypes != null && !containerTypes.isEmpty()) {
////                    // generic or array
////                    for (int i = 0; i < currentNode.size(); i++) {
////                        
////                    }
////                } else {
//                    clazz = defaultType;
////                }
//            }
//            Object result = processPrimitiveOrWrapperOrString(currentNode, clazz);
//            if (result != null) {
//                return result;
//            }
//            instance = instantiate(clazz, containerTypes, currentNode, parentInstance, fieldName, identifier);
//            if (identifier != null) {
//                deserializedObjects.put(identifier, instance);
//            }
//            
//            deserializeSubFields(currentNode, instance, null, identifier);
//            return instance;
//        } catch (Exception e) {
//            throw new AppRuntimeException(e);
//        }
    }

}
